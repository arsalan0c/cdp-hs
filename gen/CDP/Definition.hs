-- parametersElt=propertiesElt

{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TypeOperators       #-}
{-# LANGUAGE DeriveGeneric       #-}
-- | DO NOT EDIT THIS FILE MANUALLY!
--   It was automatically generated by `json-autotype`.
module CDP.Definition where
import           System.Exit        (exitFailure, exitSuccess)
import           System.IO          (stderr, hPutStrLn)
import qualified Data.ByteString.Lazy.Char8 as BSL
import           System.Environment (getArgs)
import           Control.Monad      (forM_, mzero, join)
import           Control.Applicative
import           Data.Aeson(eitherDecode, Value(..), FromJSON(..), ToJSON(..),pairs,(.:), (.:?), (.=), object)
import           Data.Monoid((<>))
import           Data.Text (Text)
import qualified GHC.Generics

data a :|: b = AltLeft a | AltRight b
    deriving (Eq, GHC.Generics.Generic, Show)

instance (FromJSON a, FromJSON b) => FromJSON (a :|: b) where
    parseJSON x = (AltLeft <$> parseJSON x) <|> (AltRight <$> parseJSON x)

data Version = Version { 
    versionMinor :: Text,
    versionMajor :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Version where
  parseJSON (Object v) = Version <$> v .:  "minor" <*> v .:  "major"
  parseJSON _          = mzero


data Items = Items { 
    itemsType :: (Maybe (Text:|:[(Maybe Value)])),
    itemsRef :: (Maybe (Text:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Items where
  parseJSON (Object v) = Items <$> v .:? "type" <*> v .:? "$ref"
  parseJSON _          = mzero


data ReturnsElt = ReturnsElt { 
    returnsEltItems :: (Maybe (Items:|:[(Maybe Value)])),
    returnsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    returnsEltName :: Text,
    returnsEltType :: (Maybe (Text:|:[(Maybe Value)])),
    returnsEltOptional :: (Maybe (Bool:|:[(Maybe Value)])),
    returnsEltRef :: (Maybe (Text:|:[(Maybe Value)])),
    returnsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    returnsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON ReturnsElt where
  parseJSON (Object v) = ReturnsElt <$> v .:? "items" <*> v .:? "experimental" <*> v .:  "name" <*> v .:? "type" <*> v .:? "optional" <*> v .:? "$ref" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


data ParametersElt = ParametersElt { 
    parametersEltItems :: (Maybe (Items:|:[(Maybe Value)])),
    parametersEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    parametersEltName :: Text,
    parametersEltType :: (Maybe (Text:|:[(Maybe Value)])),
    parametersEltEnum :: (Maybe ([Text])),
    parametersEltOptional :: (Maybe (Bool:|:[(Maybe Value)])),
    parametersEltRef :: (Maybe (Text:|:[(Maybe Value)])),
    parametersEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    parametersEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON ParametersElt where
  parseJSON (Object v) = ParametersElt <$> v .:? "items" <*> v .:? "experimental" <*> v .:  "name" <*> v .:? "type" <*> v .:? "enum" <*> v .:? "optional" <*> v .:? "$ref" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


data CommandsElt = CommandsElt { 
    commandsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    commandsEltName :: Text,
    commandsEltReturns :: (Maybe ([ReturnsElt])),
    commandsEltParameters :: (Maybe ([ParametersElt])),
    commandsEltRedirect :: (Maybe (Text:|:[(Maybe Value)])),
    commandsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    commandsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON CommandsElt where
  parseJSON (Object v) = CommandsElt <$> v .:? "experimental" <*> v .:  "name" <*> v .:? "returns" <*> v .:? "parameters" <*> v .:? "redirect" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


data TypesElt = TypesElt { 
    typesEltItems :: (Maybe (Items:|:[(Maybe Value)])),
    typesEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    typesEltId :: Text,
    typesEltType :: Text,
    typesEltEnum :: (Maybe ([Text])),
    typesEltProperties :: (Maybe ([ParametersElt])),
    typesEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    typesEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON TypesElt where
  parseJSON (Object v) = TypesElt <$> v .:? "items" <*> v .:? "experimental" <*> v .:  "id" <*> v .:  "type" <*> v .:? "enum" <*> v .:? "properties" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


data EventsElt = EventsElt { 
    eventsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    eventsEltName :: Text,
    eventsEltParameters :: (Maybe ([ParametersElt])),
    eventsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    eventsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON EventsElt where
  parseJSON (Object v) = EventsElt <$> v .:? "experimental" <*> v .:  "name" <*> v .:? "parameters" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


data DomainsElt = DomainsElt { 
    domainsEltCommands :: [CommandsElt],
    domainsEltDomain :: Text,
    domainsEltDependencies :: (Maybe ([Text])),
    domainsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    domainsEltTypes :: (Maybe ([TypesElt])),
    domainsEltEvents :: (Maybe ([EventsElt])),
    domainsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    domainsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON DomainsElt where
  parseJSON (Object v) = DomainsElt <$> v .:  "commands" <*> v .:  "domain" <*> v .:? "dependencies" <*> v .:? "experimental" <*> v .:? "types" <*> v .:? "events" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


data TopLevel = TopLevel { 
    topLevelVersion :: Version,
    topLevelDomains :: [DomainsElt]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON TopLevel where
  parseJSON (Object v) = TopLevel <$> v .:  "version" <*> v .:  "domains"
  parseJSON _          = mzero




-- | Use parser to get TopLevel object
parse :: FilePath -> IO TopLevel
parse filename = do
    input <- BSL.readFile filename
    case eitherDecode input of
      Left errTop -> fatal $ case (eitherDecode input :: Either String Value) of
                           Left  err -> "Invalid JSON file: " ++ filename ++ "\n   " ++ err
                           Right _   -> "Mismatched JSON value from file: " ++ filename
                                     ++ "\n" ++ errTop
      Right r     -> return (r :: TopLevel)
  where
    fatal :: String -> IO a
    fatal msg = do hPutStrLn stderr msg
                   exitFailure

-- | For quick testing
main :: IO ()
main = do
  filenames <- getArgs
  forM_ filenames (\f -> parse f >>= (\p -> p `seq` putStrLn $ "Successfully parsed " ++ f))
  exitSuccess

