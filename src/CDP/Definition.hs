-- parametersElt=propertiesElt

{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RecordWildCards     #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TypeOperators       #-}
{-# LANGUAGE DeriveGeneric       #-}
-- | DO NOT EDIT THIS FILE MANUALLY!
--   It was automatically generated by `json-autotype`.
module CDP.Definition where
import           System.Exit        (exitFailure, exitSuccess)
import           System.IO          (stderr, hPutStrLn)
import qualified Data.ByteString.Lazy.Char8 as BSL
import           System.Environment (getArgs)
import           Control.Monad      (forM_, mzero, join)
import           Control.Applicative
import           Data.Aeson.AutoType.Alternative
import           Data.Aeson(eitherDecode, Value(..), FromJSON(..), ToJSON(..),pairs,(.:), (.:?), (.=), object)
import           Data.Monoid((<>))
import           Data.Text (Text)
import qualified GHC.Generics

data Version = Version { 
    versionMinor :: Text,
    versionMajor :: Text
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Version where
  parseJSON (Object v) = Version <$> v .:  "minor" <*> v .:  "major"
  parseJSON _          = mzero


instance ToJSON Version where
  toJSON     (Version {..}) = object ["minor" .= versionMinor, "major" .= versionMajor]
  toEncoding (Version {..}) = pairs  ("minor" .= versionMinor<>"major" .= versionMajor)


data Items = Items { 
    itemsType :: (Maybe (Text:|:[(Maybe Value)])),
    itemsRef :: (Maybe (Text:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON Items where
  parseJSON (Object v) = Items <$> v .:? "type" <*> v .:? "$ref"
  parseJSON _          = mzero


instance ToJSON Items where
  toJSON     (Items {..}) = object ["type" .= itemsType, "$ref" .= itemsRef]
  toEncoding (Items {..}) = pairs  ("type" .= itemsType<>"$ref" .= itemsRef)


data ReturnsElt = ReturnsElt { 
    returnsEltItems :: (Maybe (Items:|:[(Maybe Value)])),
    returnsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    returnsEltName :: Text,
    returnsEltType :: (Maybe (Text:|:[(Maybe Value)])),
    returnsEltOptional :: (Maybe (Bool:|:[(Maybe Value)])),
    returnsEltRef :: (Maybe (Text:|:[(Maybe Value)])),
    returnsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    returnsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON ReturnsElt where
  parseJSON (Object v) = ReturnsElt <$> v .:? "items" <*> v .:? "experimental" <*> v .:  "name" <*> v .:? "type" <*> v .:? "optional" <*> v .:? "$ref" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


instance ToJSON ReturnsElt where
  toJSON     (ReturnsElt {..}) = object ["items" .= returnsEltItems, "experimental" .= returnsEltExperimental, "name" .= returnsEltName, "type" .= returnsEltType, "optional" .= returnsEltOptional, "$ref" .= returnsEltRef, "description" .= returnsEltDescription, "deprecated" .= returnsEltDeprecated]
  toEncoding (ReturnsElt {..}) = pairs  ("items" .= returnsEltItems<>"experimental" .= returnsEltExperimental<>"name" .= returnsEltName<>"type" .= returnsEltType<>"optional" .= returnsEltOptional<>"$ref" .= returnsEltRef<>"description" .= returnsEltDescription<>"deprecated" .= returnsEltDeprecated)


data ParametersElt = ParametersElt { 
    parametersEltItems :: (Maybe (Items:|:[(Maybe Value)])),
    parametersEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    parametersEltName :: Text,
    parametersEltType :: (Maybe (Text:|:[(Maybe Value)])),
    parametersEltEnum :: (Maybe ([Text])),
    parametersEltOptional :: (Maybe (Bool:|:[(Maybe Value)])),
    parametersEltRef :: (Maybe (Text:|:[(Maybe Value)])),
    parametersEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    parametersEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON ParametersElt where
  parseJSON (Object v) = ParametersElt <$> v .:? "items" <*> v .:? "experimental" <*> v .:  "name" <*> v .:? "type" <*> v .:? "enum" <*> v .:? "optional" <*> v .:? "$ref" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


instance ToJSON ParametersElt where
  toJSON     (ParametersElt {..}) = object ["items" .= parametersEltItems, "experimental" .= parametersEltExperimental, "name" .= parametersEltName, "type" .= parametersEltType, "enum" .= parametersEltEnum, "optional" .= parametersEltOptional, "$ref" .= parametersEltRef, "description" .= parametersEltDescription, "deprecated" .= parametersEltDeprecated]
  toEncoding (ParametersElt {..}) = pairs  ("items" .= parametersEltItems<>"experimental" .= parametersEltExperimental<>"name" .= parametersEltName<>"type" .= parametersEltType<>"enum" .= parametersEltEnum<>"optional" .= parametersEltOptional<>"$ref" .= parametersEltRef<>"description" .= parametersEltDescription<>"deprecated" .= parametersEltDeprecated)


data CommandsElt = CommandsElt { 
    commandsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    commandsEltName :: Text,
    commandsEltReturns :: (Maybe ([ReturnsElt])),
    commandsEltParameters :: (Maybe ([ParametersElt])),
    commandsEltRedirect :: (Maybe (Text:|:[(Maybe Value)])),
    commandsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    commandsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON CommandsElt where
  parseJSON (Object v) = CommandsElt <$> v .:? "experimental" <*> v .:  "name" <*> v .:? "returns" <*> v .:? "parameters" <*> v .:? "redirect" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


instance ToJSON CommandsElt where
  toJSON     (CommandsElt {..}) = object ["experimental" .= commandsEltExperimental, "name" .= commandsEltName, "returns" .= commandsEltReturns, "parameters" .= commandsEltParameters, "redirect" .= commandsEltRedirect, "description" .= commandsEltDescription, "deprecated" .= commandsEltDeprecated]
  toEncoding (CommandsElt {..}) = pairs  ("experimental" .= commandsEltExperimental<>"name" .= commandsEltName<>"returns" .= commandsEltReturns<>"parameters" .= commandsEltParameters<>"redirect" .= commandsEltRedirect<>"description" .= commandsEltDescription<>"deprecated" .= commandsEltDeprecated)


data TypesElt = TypesElt { 
    typesEltItems :: (Maybe (Items:|:[(Maybe Value)])),
    typesEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    typesEltId :: Text, --
    typesEltType :: Text, -- 
    typesEltEnum :: (Maybe ([Text])), --
    typesEltProperties :: (Maybe ([ParametersElt])),
    typesEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    typesEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON TypesElt where
  parseJSON (Object v) = TypesElt <$> v .:? "items" <*> v .:? "experimental" <*> v .:  "id" <*> v .:  "type" <*> v .:? "enum" <*> v .:? "properties" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


instance ToJSON TypesElt where
  toJSON     (TypesElt {..}) = object ["items" .= typesEltItems, "experimental" .= typesEltExperimental, "id" .= typesEltId, "type" .= typesEltType, "enum" .= typesEltEnum, "properties" .= typesEltProperties, "description" .= typesEltDescription, "deprecated" .= typesEltDeprecated]
  toEncoding (TypesElt {..}) = pairs  ("items" .= typesEltItems<>"experimental" .= typesEltExperimental<>"id" .= typesEltId<>"type" .= typesEltType<>"enum" .= typesEltEnum<>"properties" .= typesEltProperties<>"description" .= typesEltDescription<>"deprecated" .= typesEltDeprecated)


data EventsElt = EventsElt { 
    eventsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    eventsEltName :: Text,
    eventsEltParameters :: (Maybe ([ParametersElt])),
    eventsEltDescription :: (Maybe (Text:|:[(Maybe Value)])),
    eventsEltDeprecated :: (Maybe (Bool:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON EventsElt where
  parseJSON (Object v) = EventsElt <$> v .:? "experimental" <*> v .:  "name" <*> v .:? "parameters" <*> v .:? "description" <*> v .:? "deprecated"
  parseJSON _          = mzero


instance ToJSON EventsElt where
  toJSON     (EventsElt {..}) = object ["experimental" .= eventsEltExperimental, "name" .= eventsEltName, "parameters" .= eventsEltParameters, "description" .= eventsEltDescription, "deprecated" .= eventsEltDeprecated]
  toEncoding (EventsElt {..}) = pairs  ("experimental" .= eventsEltExperimental<>"name" .= eventsEltName<>"parameters" .= eventsEltParameters<>"description" .= eventsEltDescription<>"deprecated" .= eventsEltDeprecated)


data DomainsElt = DomainsElt { 
    domainsEltCommands :: [CommandsElt],
    domainsEltDomain :: Text,
    domainsEltDependencies :: (Maybe ([Text])), 
    domainsEltExperimental :: (Maybe (Bool:|:[(Maybe Value)])),
    domainsEltTypes :: (Maybe ([TypesElt])),
    domainsEltEvents :: (Maybe ([EventsElt])),
    domainsEltDescription :: (Maybe (Text:|:[(Maybe Value)]))
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON DomainsElt where
  parseJSON (Object v) = DomainsElt <$> v .:  "commands" <*> v .:  "domain" <*> v .:? "dependencies" <*> v .:? "experimental" <*> v .:? "types" <*> v .:? "events" <*> v .:? "description"
  parseJSON _          = mzero


instance ToJSON DomainsElt where
  toJSON     (DomainsElt {..}) = object ["commands" .= domainsEltCommands, "domain" .= domainsEltDomain, "dependencies" .= domainsEltDependencies, "experimental" .= domainsEltExperimental, "types" .= domainsEltTypes, "events" .= domainsEltEvents, "description" .= domainsEltDescription]
  toEncoding (DomainsElt {..}) = pairs  ("commands" .= domainsEltCommands<>"domain" .= domainsEltDomain<>"dependencies" .= domainsEltDependencies<>"experimental" .= domainsEltExperimental<>"types" .= domainsEltTypes<>"events" .= domainsEltEvents<>"description" .= domainsEltDescription)


data TopLevel = TopLevel { 
    topLevelVersion :: Version,
    topLevelDomains :: [DomainsElt]
  } deriving (Show,Eq,GHC.Generics.Generic)


instance FromJSON TopLevel where
  parseJSON (Object v) = TopLevel <$> v .:  "version" <*> v .:  "domains"
  parseJSON _          = mzero


instance ToJSON TopLevel where
  toJSON     (TopLevel {..}) = object ["version" .= topLevelVersion, "domains" .= topLevelDomains]
  toEncoding (TopLevel {..}) = pairs  ("version" .= topLevelVersion<>"domains" .= topLevelDomains)





parse :: FilePath -> IO TopLevel
parse fp = do
    res <- parse' fp
    pure res

-- | Use parser to get TopLevel object
parse' :: FilePath -> IO TopLevel
parse' filename = do
    input <- BSL.readFile filename
    case eitherDecode input of
      Left errTop -> fatal $ case (eitherDecode input :: Either String Value) of
                           Left  err -> "Invalid JSON file: " ++ filename ++ "\n   " ++ err
                           Right _   -> "Mismatched JSON value from file: " ++ filename
                                     ++ "\n" ++ errTop
      Right r     -> return (r :: TopLevel)
  where
    fatal :: String -> IO a
    fatal msg = do hPutStrLn stderr msg
                   exitFailure

-- | For quick testing
main :: IO ()
main = do
  filenames <- getArgs
  forM_ filenames (\f -> parse f >>= (\p -> p `seq` putStrLn $ "Successfully parsed " ++ f))
  exitSuccess

