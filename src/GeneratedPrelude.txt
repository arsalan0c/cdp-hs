{-# LANGUAGE OverloadedStrings, RecordWildCards, TupleSections, GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE AllowAmbiguousTypes    #-}
{-# LANGUAGE DataKinds              #-}
{-# LANGUAGE FlexibleContexts       #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs                  #-}
{-# LANGUAGE PolyKinds              #-}
{-# LANGUAGE RankNTypes             #-}
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE TypeApplications       #-}
{-# LANGUAGE TypeFamilies           #-}
{-# LANGUAGE TypeOperators          #-}
{-# LANGUAGE UndecidableInstances   #-}
{-# LANGUAGE DeriveGeneric #-}

module CDP (module CDP) where


import           Control.Applicative  ((<$>))
import           Control.Monad
import           Control.Monad.Loops
import           Control.Monad.Trans  (liftIO)
import qualified Data.Map             as M
import           Data.Maybe          
import Data.Functor.Identity
import Data.String
import qualified Data.Text as T
import qualified Data.List as List
import qualified Data.Text.IO         as TI
import qualified Data.Vector          as V
import Data.Aeson.Types (Parser(..))
import           Data.Aeson           (FromJSON (..), ToJSON (..), (.:), (.:?), (.=), (.!=), (.:!))
import qualified Data.Aeson           as A
import qualified Network.HTTP.Simple as Http
import qualified Network.URI          as Uri
import qualified Network.WebSockets as WS
import Control.Concurrent
import qualified Text.Casing as C
import qualified Data.ByteString.Lazy as BS
import qualified Data.Map as Map
import Data.Proxy
import System.Random
import GHC.Generics
import Data.Char

import CDPPrelude


type ClientApp b = Session -> IO b
data Session = Session { unSession :: Session' Event }  

runClient  :: Maybe (String, Int) -> ClientApp a -> IO a
runClient hostPort app = runClient' hostPort (app . Session)

subscribe :: forall a. FromEvent Event a => Session -> (a -> IO ()) -> IO ()
subscribe session h = subscribe' (unSession session) h

unsubscribe :: forall a. FromEvent Event a => Session -> Proxy a -> IO ()
unsubscribe session p = unsubscribe' (unSession session) p

sendReceiveCommand :: (Show a, ToJSON a) => Session -> String -> Maybe a -> IO (Maybe Error)
sendReceiveCommand session = sendReceiveCommand' (unSession session)

sendReceiveCommandResult :: forall a b s. (Show a, ToJSON a, Command b) => Session -> String -> Maybe a -> IO (Either Error b)
sendReceiveCommandResult session = sendReceiveCommandResult' (unSession session)

uncapitalizeFirst [] = []
uncapitalizeFirst (hd:tl) = toLower hd : tl